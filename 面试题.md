### 初级题目
```
go中的引用类型：
   切片，map，channel，interface，函数
```
```
new和make的区别：
  适用范围：make只能创建内建类型(slice，map，channel)， new则是可以对所有类型进行内存分配
  返回值： new返回指针， make返回引用
  填充值： new 填充零值， make 填充非零值
```
```
异常触发的情况有哪些：
  空指针解析，下标越界，除数为0，调用panic函数
```
```
cap()和len()函数的区别是什么？
  len()返回切片中的元素个数。
  cap()返回切片的容量即切片可以容纳的元素数量。
```
```
cap函数的适用类型：
  array，slice，channel。 （注：map不可以使用cap）
```
```
切片和数组的差异：
  数组大小是固定的，切片大小不是。在运行时可以动态地增加或减少切片的大小，但数组不可以。在go中，数组是切片的底层实现。
```
```
多个defer出现的时候，defer的执行顺序：
  根据defer出现的逆序执行
```

```
短变量声明的使用场景：
   只可用于函数体内部
```
   
```
进程、线程、协程之间的区别：
```
```
channel有哪些特性？
   给一个 nil channel 发送数据，造成永远阻塞
   从一个 nil channel 接收数据，造成永远阻塞
   给一个已经关闭的 channel 发送数据，引起 panic
   从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
   无缓冲的channel是同步的，而有缓冲的channel是非同步的
```
```
select与switch的区别
```


### 中级题目
```
init函数的作用有哪些？
   init()函数会在每个包完成初始化后自动执行，而且执行优先级比main函数高。init函数通常用来：
   1. 初始化变量
   2. 注册
   3. 检查/修复程序的状态
   4. 运行一次计算
init函数的特性：
   1. init函数不需要传入参数，也没有返回值。
   2. 与main函数相比，init没有被声明，所以不能被其他函数调用，在main函数执行之前自动执行
   3. 每个包可以有多个init函数，每个包的源文件也可以有多个init函数
   4. 同一个包中的多个init函数的执行顺序没有明确定义，但是不同包的init函数是由包导入的依赖关系决定的。

   如果只想使用执行某个包的init函数，可以使用import _ "/包名"的格式，防止产生编译错误
``` 
```
包的初始化顺序：
   初始化总是以单线程执行，按照包的依赖关系顺序执行，这通过go的运行时系统控制，初始化顺序：
   1. 初始化导入的包（递归导入）
   2. 对包块中声明的变量进行计算和分配初始值
   3. 执行包中的init函数
```
```
类型断言的作用：
   将接口类型的值（x）转化成类型（T），格式为 x.(T);
   value, ok :=x.(T)
类型断言的条件：x必须是接口类型，非接口类型不能做类型断言。
T可以是非接口类型，如果想断言合法，T必须实现x的接口
T也可以是接口类型，则x的动态类型也应该实现接口T
接口变量的类型也可以使用特殊形式的swtich检查：
   swich x.(type){
   case bool:
   ...
   }
```
   
### 高级题目

垃圾回收方法
常用的垃圾回收主要有引用计数，标记-清除，分代收集，三色标记
go用的是三色标记。
首先创建三个集合：白、灰、黑。
将所有对象放入白色集合中。
然后从根节点开始遍历所有对象（注意这里并不递归遍历），把遍历到的对象从白色集合放入灰色集合。
之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
重复 4 直到灰色中无任何对象
重复以上操作
收集所有白色对象（垃圾）
```
