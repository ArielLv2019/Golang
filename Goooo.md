### 初级题目
```
go中的引用类型：
   切片，map，channel，interface，函数
值类型：
   数组，基础数据结构，结构体
```
```
slice
https://zhuanlan.zhihu.com/p/61121325
```
```
map
https://www.cnblogs.com/qcrao-2018/p/10903807.html
```
```
new和make的区别：
  适用范围：make只能创建内建类型(slice，map，channel，因为它们都指向底层数据结构，都需要为底层数据结构分配好内存并初始化)， 
          new则是可以对所有类型进行内存分配
  返回值： new返回指针， make返回引用
  填充值： new 填充零值， make 填充非零值
  make()比new()多一些操作，new()只会进行内存分配并做默认的赋0初始化。（例：用make创建slice，make()可以先为底层数组分配好内存，然后从这个底层数组中再额外生成一个slice并初始化。
```
```
异常触发的情况有哪些：
  空指针解析，下标越界，除数为0，调用panic函数
```
```
cap()和len()函数的区别是什么？
  len()返回切片中的元素个数。
  cap()返回切片的容量即切片可以容纳的元素数量。
  
cap函数的适用类型：
  array，slice，channel。 （注：map不可以使用cap）
```
```
切片和数组的差异：
  数组大小是固定的，切片大小不是。在运行时可以动态地增加或减少切片的大小，但数组不可以。在go中，数组是切片的底层实现。
```
```
字典Map：

哪些类型不能做字典的键：
   函数，字典，切片。 （因为键的类型必须支持判等操作）
如果向一个值为nil的字典中添加元素，会报什么错？
   会抛一个panic
```
```
Go有继承吗？如何实现的继承？
   go没有继承，通过嵌入字段实现了类型之间的组合。
```
```
Defer
https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466918&idx=2&sn=151a8135f22563b7b97bf01ff480497b&chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&scene=21#wechat_redirect

多个defer出现的时候，defer的执行顺序：
 defer函数调用的执行顺序与他们所属的defer语句出现的顺序相反。
```

```
短变量声明的使用场景：
   只可用于函数体内部
```
   
```
进程、线程、协程之间的区别：
```

```
channel有哪些特性？
   给一个 nil channel 发送数据，造成永远阻塞
   从一个 nil channel 接收数据，造成永远阻塞
   给一个已经关闭的 channel 发送数据，引起 panic
   从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
   无缓冲的channel是同步的，而有缓冲的channel是非同步的
```
```
select与switch的区别
```
```
Go 协程相比于线程的优势:

相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。

Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。
如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。
所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。

Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。信道可以看作是 Go 协程之间通信的管道。
```

### 中级题目
```
主协程等待其他协程结束的方法：
   1. time.sleep()
   2. 通道
   3. sync.WaitGroup
```
```
init函数的作用有哪些？
   init()函数会在每个包完成初始化后自动执行，而且执行优先级比main函数高。init函数通常用来：
   1. 初始化变量
   2. 注册
   3. 检查/修复程序的状态
   4. 运行一次计算
init函数的特性：
   1. init函数不需要传入参数，也没有返回值。
   2. 与main函数相比，init没有被声明，所以不能被其他函数调用，在main函数执行之前自动执行
   3. 每个包可以有多个init函数，每个包的源文件也可以有多个init函数
   4. 同一个包中的多个init函数的执行顺序没有明确定义，但是不同包的init函数是由包导入的依赖关系决定的。

   如果只想使用执行某个包的init函数，可以使用import _ "/包名"的格式，防止产生编译错误
``` 
```
包的初始化顺序：
   初始化总是以单线程执行，按照包的依赖关系顺序执行，这通过go的运行时系统控制，初始化顺序：
   1. 初始化导入的包（递归导入）
   2. 对包块中声明的变量进行计算和分配初始值
   3. 执行包中的init函数
```
```
类型断言的作用：
   将接口类型的值（x）转化成类型（T），格式为 x.(T);
   value, ok :=x.(T)
类型断言的条件：x必须是接口类型，非接口类型不能做类型断言。
T可以是非接口类型，如果想断言合法，T必须实现x的接口
T也可以是接口类型，则x的动态类型也应该实现接口T
接口变量的类型也可以使用特殊形式的swtich检查：
   swich x.(type){
   case bool:
   ...
   }
```
```
类型别名与类型声明的区别：
语法：
   type D = int // 类型别名：有一个等号
   type I int   // 类型声明
区别：
   类型别名和原类型一样，只是另一种叫法。二者可以当作同一种类型。别名只是在源码中存在，编译完成后，不会有别名类型。
   类型定义和原类型是不同的两个类型，他们之间不可以进行类型转换，他们的值之间也不能进行判等或比较，他们的变量也不能互相赋值。
```
```
切片扩容：
   <1024: 原长度*2;
   >1024: 原长度*1.25
```
```
值方法和指针方法的区别
   （方法的接收者必须是某个自定义的数据类型，且不能是接口类型或接口的指针类型）
   1. 一个方法的接受类型是所属类型的指针类型，就可以称此方法为指针方法
   2. 如果接受类型是所属类型本身，此方法叫做值方法。
   3. 值方法的修改不会体现在原值上，除非这个类型本身是某个引用类型（比如切片，map）的别名类型
   4. 指针方法的修改会体现在原值上。
   
Note： 
   自定义数据类型的方法集合仅有值方法。
   某个类型的指针类型的方法集合=值方法+指针方法
   但go会适时的进行转译，所以在值上也能调用指针方法
```
```
struct{}:
   空结构体，不占用内存空间。但是有结构体的一切属性，例如可以绑定方法，可以写入channel。
```
### 高级题目
```
contianer包中的容器，List与Ring（循环链表）的区别：
   1. ring的数据结构由它中级代表，而list需要由它以及Element类型联合表示
   2. 一个ring值只代表其所属循环链表中的一个元素，一个List类型的值代表了一个完整的链表
   3. Ring一旦被创建，长度不可改变
Element{
   next, prev *Element // 节点前后的元素
   list *List          // Element所属的list
   value interface{}   // Element存储的值
}
List{
   root Element
   len int
}
```
```
goroutine的调度模型：
https://studygolang.com/articles/20991
   通过GPM调度模型实现：
   Go的调度器内部有四个重要的结构：M，P，S，Sched。
   M:M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息
   G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。
   P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine
   Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。
```

```
垃圾回收方法
常用的垃圾回收主要有引用计数，标记-清除，分代收集，三色标记
go用的是三色标记。
首先创建三个集合：白、灰、黑。
将所有对象放入白色集合中。
然后从根节点开始遍历所有对象（注意这里并不递归遍历），把遍历到的对象从白色集合放入灰色集合。
之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
重复 4 直到灰色中无任何对象
重复以上操作
收集所有白色对象（垃圾）
```
```
Go语言局部变量分配在栈还是堆？

Go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析，
当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。
```
